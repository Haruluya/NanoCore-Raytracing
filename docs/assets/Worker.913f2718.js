(function(){"use strict";const g=(i,t,e)=>(e=e||new Float32Array(3),e[0]=i[0]+t[0],e[1]=i[1]+t[1],e[2]=i[2]+t[2],e),d=(i,t)=>[i[0]-t[0],i[1]-t[1],i[2]-t[2]],w=i=>{var t=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]);return t>1e-5?[i[0]/t,i[1]/t,i[2]/t]:[0,0,0]},m=(i,t)=>i[0]*t[0]+i[1]*t[1]+i[2]*t[2],b=i=>i[0]*i[0]+i[1]*i[1]+i[2]*i[2],p=(i,t)=>[i[0]*t,i[1]*t,i[2]*t],F=(i,t,e)=>{let s=m(p(i,-1),t)<1?m(p(i,-1),t):1,n=p(e,g(i,p(t,s))),r=p(t,-Math.sqrt(Math.abs(1-b(n))));return g(n,r)},Y=(i,t)=>d(i,p(t,2*m(i,t))),O=(i,t)=>[i[0]*t[0],i[1]*t[1],i[2]*t[2]],U=3.141592653589793,_=(i,t)=>i!=null&&t!=null?i+(t-i)*Math.random():Math.random(),V=(i,t)=>i&&t?[_(i,t),_(i,t),_(i,t)]:[_(),_(),_()],Z=()=>{for(;;){let i=V(-1,1);if(!(Math.pow(i[0]*i[0]+i[1]*i[1]+i[2]*i[2],2)>=1))return i}},G=()=>{const i=_(0,2*U),t=_(-1,1),e=Math.sqrt(1-t*t);return[e*Math.cos(i),e*Math.sin(i),t]};class q{constructor(t,e){this.m_origin=t,this.m_direction=e}get origin(){return this.m_origin}get direction(){return this.m_direction}setDirection(t){this.m_direction=t}setOrigin(t){this.m_origin=t}at(t){return g(this.m_origin,p(this.m_direction,t))}}class H{constructor(t,e,s,n){this.p=t,this.normal=e,this.t=s,this.front_face=n,this.mat_ptr=null}set_face_normal(t,e){front_face=m(t.direction,e)<0,normal=front_face?e:-e}}class C{hit(t,e,s,n){}}class J extends C{constructor(t){super(),this.objects=t}add(t){this.objects.push(t)}clear(){this.objects=[]}hit(t,e,s,n){let r=!1,a=s;return this.objects.forEach(h=>{h.hit(t,e,a,n)&&(r=!0,a=n.t)}),r}}class A{scatter(t,e){}}class I extends C{constructor(t,e,s){super(),this.center=t,this.radius=e,this.mat_ptr=s}hit(t,e,s,n){let r=d(t.origin,this.center),a=b(t.direction),h=m(r,t.direction),f=b(r)-this.radius*this.radius,l=h*h-a*f;if(l>0){let c=Math.sqrt(l),o=(-h-c)/a;if(o<s&&o>e)return n.t=o,n.p=t.at(n.t),n.normal=p(d(n.p,this.center),1/this.radius),n.mat_ptr=this.mat_ptr,!0;if(o=(-h+c)/a,o<s&&o>e)return n.t=o,n.p=t.at(n.t),n.normal=p(d(n.p,this.center),1/this.radius),n.mat_ptr=this.mat_ptr,!0}return!1}}class K extends C{constructor(t,e,s){super(),this.min=t,this.max=e,this.mat_ptr=s}hit(t,e,s,n){let r,a,h=1/t.direction[0],f=1/t.direction[1],l=1/t.direction[2],c=(this.min[0]-t.origin[0])*h,o=(this.max[0]-t.origin[0])*h;if(r=Math.min(c,o),a=Math.max(c,o),c=(this.min[1]-t.origin[1])*f,o=(this.max[1]-t.origin[1])*f,r=Math.max(r,Math.min(c,o)),a=Math.min(a,Math.max(c,o)),c=(this.min[2]-t.origin[2])*l,o=(this.max[2]-t.origin[2])*l,r=Math.max(r,Math.min(c,o)),a=Math.min(a,Math.max(c,o)),a<r)return!1;if(r>e&&a<s)n.t=r;else if(a>e&&a<s)n.t=a;else return!1;n.p=[t.origin[0]+n.t*t.direction[0],t.origin[1]+n.t*t.direction[1],t.origin[2]+n.t*t.direction[2]];let u=[0,0,0];return n.p[0]<this.min[0]+1e-4?u[0]=-1:n.p[0]>this.max[0]-1e-4&&(u[0]=1),n.p[1]<this.min[1]+1e-4?u[1]=-1:n.p[1]>this.max[1]-1e-4&&(u[1]=1),n.p[2]<this.min[2]+1e-4?u[2]=-1:n.p[2]>this.max[2]-1e-4&&(u[2]=1),n.normal=u,n.mat_ptr=this.mat_ptr,!0}}class P extends C{constructor(t,e,s,n){super(),this.center=t,this.radius=e,this.height=s,this.mat_ptr=n}hit(t,e,s,n){const r=d(t.origin,this.center),a=b(t.direction)-Math.pow(m(t.direction,this.axis()),2),h=m(r,t.direction)-m(r,this.axis())*m(t.direction,this.axis()),f=b(r)-Math.pow(m(r,this.axis()),2)-Math.pow(this.radius,2),l=Math.pow(h,2)-a*f;if(l>0){let c=Math.sqrt(l),o=(-h-c)/a;if(o<s&&o>e&&this.isWithinBounds(o,t)){n.t=o,n.p=t.at(n.t);const u=w(d(d(n.p,this.center),p(this.axis(),m(d(n.p,this.center),this.axis()))));return n.normal=u,n.mat_ptr=this.mat_ptr,!0}if(o=(-h+c)/a,o<s&&o>e&&this.isWithinBounds(o,t)){n.t=o,n.p=t.at(n.t);const u=w(d(d(n.p,this.center),p(this.axis(),m(d(n.p,this.center),this.axis()))));return n.normal=u,n.mat_ptr=this.mat_ptr,!0}}return!1}axis(){return[0,1,0]}isWithinBounds(t,e){const s=e.origin[1]+t*e.direction[1];return s>=this.center[1]&&s<=this.center[1]+this.height}}class L extends A{constructor(t){super(),this.albedo=t}scatter(t,e){let s=g(e.normal,G());const n=new q(e.p,s),r=this.albedo;return{scatter:!0,scattered:n,attenuation:r}}}class Q extends A{constructor(t,e){super(),this.albedo=t,this.fuzz=e<1?e:1}scatter(t,e){const s=Y(w(t.direction),e.normal),n=new q(e.p,g(s,p(Z(),this.fuzz))),r=this.albedo;return{scatter:m(n.direction,e.normal)>0,scattered:n,attenuation:r}}}class N extends A{constructor(t){super(),this.m_ir=t}scatter(t,e){let s=[1,1,1],n=e.front_face?1/this.m_ir:this.m_ir,r=w(t.direction),a=Math.min(m(p(r,-1),e.normal),1),h=Math.sqrt(1-a*a),f=n*h>1,l;return f||N.reflectance(a,n)?l=Y(r,e.normal):l=F(r,e.normal,n),{scatter:!0,scattered:new q(e.p,l),attenuation:s}}static reflectance(t,e){let s=(1-e)/(1+e);return s=s*s,s+(1-s)*Math.pow(1-t,5)}}let x=new J([]),W=new H;const S=(i,t)=>{if(t<=0)return[0,0,0];if(x.hit(i,.001,99999,W)){const{scatter:e,scattered:s,attenuation:n}=W.mat_ptr.scatter(i,W);return e?O(n,S(s,t-1)):[0,0,0]}else{let s=(w(i.direction)[1]+1)*.5;return[255*(1-.5*s),255*(1-.3*s),255]}};self.onmessage=function(i){const{width:t,height:e,max_depth:s,origin:n,bgCircleCenter:r,circleCenter:a,radius:h,samples_per_pixel:f,startX:l,startY:c,endX:o,endY:u}=i.data;let M;const T=1/t,$=1/e,k=t/e;let j,y=new q(n,n);x.clear(),x.add(new I(g(r,d([.5,.5,1],[.5,.5,1])),100,new L([.8,.8,0]))),x.add(new I(g(a,d([.5,.5,1],[.5,.5,1])),h+.05,new N(1.5))),x.add(new K(d(a,[.4,.1,0]),g(a,[h-.3,h,h]),new L([.8,.8,.8]))),x.add(new P(g(a,[.3,-.1,0]),h,.2,new Q([.8,.6,.2],1)));let X=0;l==t/2&&c==e/2?X=-t/2:l==0&&c==e/2&&(X=t/2);const D=new Uint8ClampedArray((o-l)*(u-c)*4);for(let z=l;z<o;z++){const v=(z+.5+X)*T;for(let B=c;B<u;B++){const tt=(B+.5)*$;M=[0,0,0];for(let E=0;E<f;E++)y.setDirection([k*(v-y.origin[0]+_(0,.001)),tt-y.origin[1]+_(0,.001),-y.origin[2]]),j=S(y,s),M[0]+=j[0],M[1]+=j[1],M[2]+=j[2];const R=(z-l+(B-c)*(o-l))*4;D[R+0]=M[0]/f,D[R+1]=M[1]/f,D[R+2]=M[2]/f,D[R+3]=255}}self.postMessage({partImageData:D,startX:l,startY:c,endX:o,endY:u})}})();
