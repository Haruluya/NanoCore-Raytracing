(function(){"use strict";const _=(i,t,n)=>(n=n||new Float32Array(3),n[0]=i[0]+t[0],n[1]=i[1]+t[1],n[2]=i[2]+t[2],n),d=(i,t)=>[i[0]-t[0],i[1]-t[1],i[2]-t[2]],y=i=>{var t=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]);return t>1e-5?[i[0]/t,i[1]/t,i[2]/t]:[0,0,0]},m=(i,t)=>i[0]*t[0]+i[1]*t[1]+i[2]*t[2],D=i=>i[0]*i[0]+i[1]*i[1]+i[2]*i[2],g=(i,t)=>[i[0]*t,i[1]*t,i[2]*t],E=(i,t)=>d(i,g(t,2*m(i,t))),F=(i,t)=>[i[0]*t[0],i[1]*t[1],i[2]*t[2]],O=3.141592653589793,f=(i,t)=>i!=null&&t!=null?i+(t-i)*Math.random():Math.random(),U=(i,t)=>i&&t?[f(i,t),f(i,t),f(i,t)]:[f(),f(),f()],V=()=>{for(;;){let i=U(-1,1);if(!(Math.pow(i[0]*i[0]+i[1]*i[1]+i[2]*i[2],2)>=1))return i}},Z=()=>{const i=f(0,2*O),t=f(-1,1),n=Math.sqrt(1-t*t);return[n*Math.cos(i),n*Math.sin(i),t]};class A{constructor(t,n){this.m_origin=t,this.m_direction=n}get origin(){return this.m_origin}get direction(){return this.m_direction}setDirection(t){this.m_direction=t}setOrigin(t){this.m_origin=t}at(t){return _(this.m_origin,g(this.m_direction,t))}}class G{constructor(t,n,s,e){this.p=t,this.normal=n,this.t=s,this.front_face=e,this.mat_ptr=null}set_face_normal(t,n){front_face=m(t.direction,n)<0,normal=front_face?n:-n}}class C{hit(t,n,s,e){}}class H extends C{constructor(t){super(),this.objects=t}add(t){this.objects.push(t)}clear(){this.objects=[]}hit(t,n,s,e){let a=!1,o=s;return this.objects.forEach(c=>{c.hit(t,n,o,e)&&(a=!0,o=e.t)}),a}}class R{scatter(t,n){}}class W extends C{constructor(t,n,s){super(),this.center=t,this.radius=n,this.mat_ptr=s}hit(t,n,s,e){let a=d(t.origin,this.center),o=D(t.direction),c=m(a,t.direction),p=D(a)-this.radius*this.radius,l=c*c-o*p;if(l>0){let h=Math.sqrt(l),r=(-c-h)/o;if(r<s&&r>n)return e.t=r,e.p=t.at(e.t),e.normal=g(d(e.p,this.center),1/this.radius),e.mat_ptr=this.mat_ptr,!0;if(r=(-c+h)/o,r<s&&r>n)return e.t=r,e.p=t.at(e.t),e.normal=g(d(e.p,this.center),1/this.radius),e.mat_ptr=this.mat_ptr,!0}return!1}}class J extends C{constructor(t,n,s){super(),this.min=t,this.max=n,this.mat_ptr=s}hit(t,n,s,e){let a,o,c=1/t.direction[0],p=1/t.direction[1],l=1/t.direction[2],h=(this.min[0]-t.origin[0])*c,r=(this.max[0]-t.origin[0])*c;if(a=Math.min(h,r),o=Math.max(h,r),h=(this.min[1]-t.origin[1])*p,r=(this.max[1]-t.origin[1])*p,a=Math.max(a,Math.min(h,r)),o=Math.min(o,Math.max(h,r)),h=(this.min[2]-t.origin[2])*l,r=(this.max[2]-t.origin[2])*l,a=Math.max(a,Math.min(h,r)),o=Math.min(o,Math.max(h,r)),o<a)return!1;if(a>n&&o<s)e.t=a;else if(o>n&&o<s)e.t=o;else return!1;e.p=[t.origin[0]+e.t*t.direction[0],t.origin[1]+e.t*t.direction[1],t.origin[2]+e.t*t.direction[2]];let u=[0,0,0];return e.p[0]<this.min[0]+1e-4?u[0]=-1:e.p[0]>this.max[0]-1e-4&&(u[0]=1),e.p[1]<this.min[1]+1e-4?u[1]=-1:e.p[1]>this.max[1]-1e-4&&(u[1]=1),e.p[2]<this.min[2]+1e-4?u[2]=-1:e.p[2]>this.max[2]-1e-4&&(u[2]=1),e.normal=u,e.mat_ptr=this.mat_ptr,!0}}class K extends C{constructor(t,n,s,e){super(),this.center=t,this.radius=n,this.height=s,this.mat_ptr=e}hit(t,n,s,e){const a=d(t.origin,this.center),o=D(t.direction)-Math.pow(m(t.direction,this.axis()),2),c=m(a,t.direction)-m(a,this.axis())*m(t.direction,this.axis()),p=D(a)-Math.pow(m(a,this.axis()),2)-Math.pow(this.radius,2),l=Math.pow(c,2)-o*p;if(l>0){let h=Math.sqrt(l),r=(-c-h)/o;if(r<s&&r>n&&this.isWithinBounds(r,t)){e.t=r,e.p=t.at(e.t);const u=y(d(d(e.p,this.center),g(this.axis(),m(d(e.p,this.center),this.axis()))));return e.normal=u,e.mat_ptr=this.mat_ptr,!0}if(r=(-c+h)/o,r<s&&r>n&&this.isWithinBounds(r,t)){e.t=r,e.p=t.at(e.t);const u=y(d(d(e.p,this.center),g(this.axis(),m(d(e.p,this.center),this.axis()))));return e.normal=u,e.mat_ptr=this.mat_ptr,!0}}return!1}axis(){return[0,1,0]}isWithinBounds(t,n){const s=n.origin[1]+t*n.direction[1];return s>=this.center[1]&&s<=this.center[1]+this.height}}class X extends R{constructor(t){super(),this.albedo=t}scatter(t,n){let s=_(n.normal,Z());const e=new A(n.p,s),a=this.albedo;return{scatter:!0,scattered:e,attenuation:a}}}class Y extends R{constructor(t,n){super(),this.albedo=t,this.fuzz=n<1?n:1}scatter(t,n){const s=E(y(t.direction),n.normal),e=new A(n.p,_(s,g(V(),this.fuzz))),a=this.albedo;return{scatter:m(e.direction,n.normal)>0,scattered:e,attenuation:a}}}let M=new H([]),N=new G;const I=(i,t)=>{if(t<=0)return[0,0,0];if(M.hit(i,.001,99999,N)){const{scatter:n,scattered:s,attenuation:e}=N.mat_ptr.scatter(i,N);return n?F(e,I(s,t-1)):[0,0,0]}else{let s=(y(i.direction)[1]+1)*.5;return[255*(1-.5*s),255*(1-.3*s),255]}};self.onmessage=function(i){const{width:t,height:n,max_depth:s,origin:e,bgCircleCenter:a,circleCenter:o,radius:c,samples_per_pixel:p,startX:l,startY:h,endX:r,endY:u}=i.data;let x;const P=1/t,Q=1/n,T=t/n;let j,w=new A(e,e);M.clear(),M.add(new W(_(a,d(e,[.5,.5,1])),100,new X([.8,.8,0]))),M.add(new W(_(o,d(e,[.5,.5,1])),c,new X([.7,.3,.3]))),M.add(new J(d(o,[.4,.1,0]),_(o,[c-.3,c,c]),new Y([.8,.8,.8],1))),M.add(new K(_(o,[.3,-.1,0]),c,.2,new Y([.8,.6,.2],1)));let L=0;l==t/2&&h==n/2&&(L=-t/2);const b=new Uint8ClampedArray((r-l)*(u-h)*4);for(let q=l;q<r;q++){const $=(q+.5+L)*P;for(let z=h;z<u;z++){const k=(z+.5)*Q;x=[0,0,0];for(let S=0;S<p;S++)w.setDirection([T*($-w.origin[0]+f(0,.001)),k-w.origin[1]+f(0,.001),-w.origin[2]]),j=I(w,s),x[0]+=j[0],x[1]+=j[1],x[2]+=j[2];const B=(q-l+(z-h)*(r-l))*4;b[B+0]=x[0]/p,b[B+1]=x[1]/p,b[B+2]=x[2]/p,b[B+3]=255}}self.postMessage({partImageData:b,startX:l,startY:h,endX:r,endY:u})}})();
