(function(){"use strict";const _=(i,t,n)=>(n=n||new Float32Array(3),n[0]=i[0]+t[0],n[1]=i[1]+t[1],n[2]=i[2]+t[2],n),u=(i,t)=>[i[0]-t[0],i[1]-t[1],i[2]-t[2]],y=i=>{var t=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]);return t>1e-5?[i[0]/t,i[1]/t,i[2]/t]:[0,0,0]},m=(i,t)=>i[0]*t[0]+i[1]*t[1]+i[2]*t[2],D=i=>i[0]*i[0]+i[1]*i[1]+i[2]*i[2],g=(i,t)=>[i[0]*t,i[1]*t,i[2]*t],S=(i,t)=>u(i,g(t,2*m(i,t))),E=(i,t)=>[i[0]*t[0],i[1]*t[1],i[2]*t[2]],F=3.141592653589793,f=(i,t)=>i!=null&&t!=null?i+(t-i)*Math.random():Math.random(),O=(i,t)=>i&&t?[f(i,t),f(i,t),f(i,t)]:[f(),f(),f()],U=()=>{for(;;){let i=O(-1,1);if(!(Math.pow(i[0]*i[0]+i[1]*i[1]+i[2]*i[2],2)>=1))return i}},V=()=>{const i=f(0,2*F),t=f(-1,1),n=Math.sqrt(1-t*t);return[n*Math.cos(i),n*Math.sin(i),t]};class A{constructor(t,n){this.m_origin=t,this.m_direction=n}get origin(){return this.m_origin}get direction(){return this.m_direction}setDirection(t){this.m_direction=t}setOrigin(t){this.m_origin=t}at(t){return _(this.m_origin,g(this.m_direction,t))}}class Z{constructor(t,n,s,e){this.p=t,this.normal=n,this.t=s,this.front_face=e,this.mat_ptr=null}set_face_normal(t,n){front_face=m(t.direction,n)<0,normal=front_face?n:-n}}class C{hit(t,n,s,e){}}class G extends C{constructor(t){super(),this.objects=t}add(t){this.objects.push(t)}clear(){this.objects=[]}hit(t,n,s,e){let a=!1,o=s;return this.objects.forEach(h=>{h.hit(t,n,o,e)&&(a=!0,o=e.t)}),a}}class R{scatter(t,n){}}class W extends C{constructor(t,n,s){super(),this.center=t,this.radius=n,this.mat_ptr=s}hit(t,n,s,e){let a=u(t.origin,this.center),o=D(t.direction),h=m(a,t.direction),p=D(a)-this.radius*this.radius,d=h*h-o*p;if(d>0){let c=Math.sqrt(d),r=(-h-c)/o;if(r<s&&r>n)return e.t=r,e.p=t.at(e.t),e.normal=g(u(e.p,this.center),1/this.radius),e.mat_ptr=this.mat_ptr,!0;if(r=(-h+c)/o,r<s&&r>n)return e.t=r,e.p=t.at(e.t),e.normal=g(u(e.p,this.center),1/this.radius),e.mat_ptr=this.mat_ptr,!0}return!1}}class H extends C{constructor(t,n,s){super(),this.min=t,this.max=n,this.mat_ptr=s}hit(t,n,s,e){let a,o,h=1/t.direction[0],p=1/t.direction[1],d=1/t.direction[2],c=(this.min[0]-t.origin[0])*h,r=(this.max[0]-t.origin[0])*h;if(a=Math.min(c,r),o=Math.max(c,r),c=(this.min[1]-t.origin[1])*p,r=(this.max[1]-t.origin[1])*p,a=Math.max(a,Math.min(c,r)),o=Math.min(o,Math.max(c,r)),c=(this.min[2]-t.origin[2])*d,r=(this.max[2]-t.origin[2])*d,a=Math.max(a,Math.min(c,r)),o=Math.min(o,Math.max(c,r)),o<a)return!1;if(a>n&&o<s)e.t=a;else if(o>n&&o<s)e.t=o;else return!1;e.p=[t.origin[0]+e.t*t.direction[0],t.origin[1]+e.t*t.direction[1],t.origin[2]+e.t*t.direction[2]];let l=[0,0,0];return e.p[0]<this.min[0]+1e-4?l[0]=-1:e.p[0]>this.max[0]-1e-4&&(l[0]=1),e.p[1]<this.min[1]+1e-4?l[1]=-1:e.p[1]>this.max[1]-1e-4&&(l[1]=1),e.p[2]<this.min[2]+1e-4?l[2]=-1:e.p[2]>this.max[2]-1e-4&&(l[2]=1),e.normal=l,e.mat_ptr=this.mat_ptr,!0}}class J extends C{constructor(t,n,s,e){super(),this.center=t,this.radius=n,this.height=s,this.mat_ptr=e}hit(t,n,s,e){const a=u(t.origin,this.center),o=D(t.direction)-Math.pow(m(t.direction,this.axis()),2),h=m(a,t.direction)-m(a,this.axis())*m(t.direction,this.axis()),p=D(a)-Math.pow(m(a,this.axis()),2)-Math.pow(this.radius,2),d=Math.pow(h,2)-o*p;if(d>0){let c=Math.sqrt(d),r=(-h-c)/o;if(r<s&&r>n&&this.isWithinBounds(r,t)){e.t=r,e.p=t.at(e.t);const l=y(u(u(e.p,this.center),g(this.axis(),m(u(e.p,this.center),this.axis()))));return e.normal=l,e.mat_ptr=this.mat_ptr,!0}if(r=(-h+c)/o,r<s&&r>n&&this.isWithinBounds(r,t)){e.t=r,e.p=t.at(e.t);const l=y(u(u(e.p,this.center),g(this.axis(),m(u(e.p,this.center),this.axis()))));return e.normal=l,e.mat_ptr=this.mat_ptr,!0}}return!1}axis(){return[0,1,0]}isWithinBounds(t,n){const s=n.origin[1]+t*n.direction[1];return s>=this.center[1]&&s<=this.center[1]+this.height}}class X extends R{constructor(t){super(),this.albedo=t}scatter(t,n){let s=_(n.normal,V());const e=new A(n.p,s),a=this.albedo;return{scatter:!0,scattered:e,attenuation:a}}}class Y extends R{constructor(t,n){super(),this.albedo=t,this.fuzz=n<1?n:1}scatter(t,n){const s=S(y(t.direction),n.normal),e=new A(n.p,_(s,g(U(),this.fuzz))),a=this.albedo;return{scatter:m(e.direction,n.normal)>0,scattered:e,attenuation:a}}}let M=new G([]),N=new Z;const I=(i,t)=>{if(t<=0)return[0,0,0];if(M.hit(i,.001,99999,N)){const{scatter:n,scattered:s,attenuation:e}=N.mat_ptr.scatter(i,N);return n?E(e,I(s,t-1)):[0,0,0]}else{let s=(y(i.direction)[1]+1)*.5;return[255*(1-.5*s),255*(1-.3*s),255]}};self.onmessage=function(i){const{width:t,height:n,max_depth:s,origin:e,bgCircleCenter:a,circleCenter:o,radius:h,samples_per_pixel:p,startX:d,startY:c,endX:r,endY:l}=i.data;let x;const K=1/t,P=1/n,Q=t/n;let j,w=new A(e,e);M.clear(),M.add(new W(_(a,u(e,[.5,.5,1])),100,new X([.8,.8,0]))),M.add(new W(_(o,u(e,[.5,.5,1])),h,new X([.7,.3,.3]))),M.add(new H(u(o,[.4,.1,0]),_(o,[h-.3,h,h]),new Y([.8,.8,.8],1))),M.add(new J(_(o,[.3,-.1,0]),h,.2,new Y([.8,.6,.2],1)));const b=new Uint8ClampedArray((r-d)*(l-c)*4);for(let q=d;q<r;q++){const T=(q+.5)*K;for(let z=c;z<l;z++){const $=(z+.5)*P;x=[0,0,0];for(let L=0;L<p;L++)w.setDirection([Q*(T-w.origin[0]+f(0,.001)),$-w.origin[1]+f(0,.001),-w.origin[2]]),j=I(w,s),x[0]+=j[0],x[1]+=j[1],x[2]+=j[2];const B=(q-d+(z-c)*(r-d))*4;b[B+0]=x[0]/p,b[B+1]=x[1]/p,b[B+2]=x[2]/p,b[B+3]=255}}self.postMessage({partImageData:b,startX:d,startY:c,endX:r,endY:l})}})();
