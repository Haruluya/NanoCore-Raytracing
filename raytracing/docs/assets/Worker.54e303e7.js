(function(){"use strict";const g=(i,t,n)=>(n=n||new Float32Array(3),n[0]=i[0]+t[0],n[1]=i[1]+t[1],n[2]=i[2]+t[2],n),d=(i,t)=>[i[0]-t[0],i[1]-t[1],i[2]-t[2]],w=i=>{var t=Math.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]);return t>1e-5?[i[0]/t,i[1]/t,i[2]/t]:[0,0,0]},m=(i,t)=>i[0]*t[0]+i[1]*t[1]+i[2]*t[2],b=i=>i[0]*i[0]+i[1]*i[1]+i[2]*i[2],p=(i,t)=>[i[0]*t,i[1]*t,i[2]*t],E=(i,t,n)=>{let s=m(p(i,-1),t)<1?m(p(i,-1),t):1,e=p(n,g(i,p(t,s))),r=p(t,-Math.sqrt(Math.abs(1-b(e))));return g(e,r)},X=(i,t)=>d(i,p(t,2*m(i,t))),F=(i,t)=>[i[0]*t[0],i[1]*t[1],i[2]*t[2]],O=3.141592653589793,f=(i,t)=>i!=null&&t!=null?i+(t-i)*Math.random():Math.random(),U=(i,t)=>i&&t?[f(i,t),f(i,t),f(i,t)]:[f(),f(),f()],V=()=>{for(;;){let i=U(-1,1);if(!(Math.pow(i[0]*i[0]+i[1]*i[1]+i[2]*i[2],2)>=1))return i}},Z=()=>{const i=f(0,2*O),t=f(-1,1),n=Math.sqrt(1-t*t);return[n*Math.cos(i),n*Math.sin(i),t]};class q{constructor(t,n){this.m_origin=t,this.m_direction=n}get origin(){return this.m_origin}get direction(){return this.m_direction}setDirection(t){this.m_direction=t}setOrigin(t){this.m_origin=t}at(t){return g(this.m_origin,p(this.m_direction,t))}}class G{constructor(t,n,s,e){this.p=t,this.normal=n,this.t=s,this.front_face=e,this.mat_ptr=null}set_face_normal(t,n){front_face=m(t.direction,n)<0,normal=front_face?n:-n}}class C{hit(t,n,s,e){}}class H extends C{constructor(t){super(),this.objects=t}add(t){this.objects.push(t)}clear(){this.objects=[]}hit(t,n,s,e){let r=!1,a=s;return this.objects.forEach(c=>{c.hit(t,n,a,e)&&(r=!0,a=e.t)}),r}}class A{scatter(t,n){}}class Y extends C{constructor(t,n,s){super(),this.center=t,this.radius=n,this.mat_ptr=s}hit(t,n,s,e){let r=d(t.origin,this.center),a=b(t.direction),c=m(r,t.direction),_=b(r)-this.radius*this.radius,l=c*c-a*_;if(l>0){let h=Math.sqrt(l),o=(-c-h)/a;if(o<s&&o>n)return e.t=o,e.p=t.at(e.t),e.normal=p(d(e.p,this.center),1/this.radius),e.mat_ptr=this.mat_ptr,!0;if(o=(-c+h)/a,o<s&&o>n)return e.t=o,e.p=t.at(e.t),e.normal=p(d(e.p,this.center),1/this.radius),e.mat_ptr=this.mat_ptr,!0}return!1}}class J extends C{constructor(t,n,s){super(),this.min=t,this.max=n,this.mat_ptr=s}hit(t,n,s,e){let r,a,c=1/t.direction[0],_=1/t.direction[1],l=1/t.direction[2],h=(this.min[0]-t.origin[0])*c,o=(this.max[0]-t.origin[0])*c;if(r=Math.min(h,o),a=Math.max(h,o),h=(this.min[1]-t.origin[1])*_,o=(this.max[1]-t.origin[1])*_,r=Math.max(r,Math.min(h,o)),a=Math.min(a,Math.max(h,o)),h=(this.min[2]-t.origin[2])*l,o=(this.max[2]-t.origin[2])*l,r=Math.max(r,Math.min(h,o)),a=Math.min(a,Math.max(h,o)),a<r)return!1;if(r>n&&a<s)e.t=r;else if(a>n&&a<s)e.t=a;else return!1;e.p=[t.origin[0]+e.t*t.direction[0],t.origin[1]+e.t*t.direction[1],t.origin[2]+e.t*t.direction[2]];let u=[0,0,0];return e.p[0]<this.min[0]+1e-4?u[0]=-1:e.p[0]>this.max[0]-1e-4&&(u[0]=1),e.p[1]<this.min[1]+1e-4?u[1]=-1:e.p[1]>this.max[1]-1e-4&&(u[1]=1),e.p[2]<this.min[2]+1e-4?u[2]=-1:e.p[2]>this.max[2]-1e-4&&(u[2]=1),e.normal=u,e.mat_ptr=this.mat_ptr,!0}}class K extends C{constructor(t,n,s,e){super(),this.center=t,this.radius=n,this.height=s,this.mat_ptr=e}hit(t,n,s,e){const r=d(t.origin,this.center),a=b(t.direction)-Math.pow(m(t.direction,this.axis()),2),c=m(r,t.direction)-m(r,this.axis())*m(t.direction,this.axis()),_=b(r)-Math.pow(m(r,this.axis()),2)-Math.pow(this.radius,2),l=Math.pow(c,2)-a*_;if(l>0){let h=Math.sqrt(l),o=(-c-h)/a;if(o<s&&o>n&&this.isWithinBounds(o,t)){e.t=o,e.p=t.at(e.t);const u=w(d(d(e.p,this.center),p(this.axis(),m(d(e.p,this.center),this.axis()))));return e.normal=u,e.mat_ptr=this.mat_ptr,!0}if(o=(-c+h)/a,o<s&&o>n&&this.isWithinBounds(o,t)){e.t=o,e.p=t.at(e.t);const u=w(d(d(e.p,this.center),p(this.axis(),m(d(e.p,this.center),this.axis()))));return e.normal=u,e.mat_ptr=this.mat_ptr,!0}}return!1}axis(){return[0,1,0]}isWithinBounds(t,n){const s=n.origin[1]+t*n.direction[1];return s>=this.center[1]&&s<=this.center[1]+this.height}}class I extends A{constructor(t){super(),this.albedo=t}scatter(t,n){let s=g(n.normal,Z());const e=new q(n.p,s),r=this.albedo;return{scatter:!0,scattered:e,attenuation:r}}}class P extends A{constructor(t,n){super(),this.albedo=t,this.fuzz=n<1?n:1}scatter(t,n){const s=X(w(t.direction),n.normal),e=new q(n.p,g(s,p(V(),this.fuzz))),r=this.albedo;return{scatter:m(e.direction,n.normal)>0,scattered:e,attenuation:r}}}class N extends A{constructor(t){super(),this.m_ir=t}scatter(t,n){let s=[1,1,1],e=n.front_face?1/this.m_ir:this.m_ir,r=w(t.direction),a=Math.min(m(p(r,-1),n.normal),1),c=Math.sqrt(1-a*a),_=e*c>1,l;return _||N.reflectance(a,e)?l=X(r,n.normal):l=E(r,n.normal,e),{scatter:!0,scattered:new q(n.p,l),attenuation:s}}static reflectance(t,n){let s=(1-n)/(1+n);return s=s*s,s+(1-s)*Math.pow(1-t,5)}}let x=new H([]),W=new G;const L=(i,t)=>{if(t<=0)return[0,0,0];if(x.hit(i,.001,99999,W)){const{scatter:n,scattered:s,attenuation:e}=W.mat_ptr.scatter(i,W);return n?F(e,L(s,t-1)):[0,0,0]}else{let s=(w(i.direction)[1]+1)*.5;return[255*(1-.5*s),255*(1-.3*s),255]}};self.onmessage=function(i){const{width:t,height:n,max_depth:s,origin:e,bgCircleCenter:r,circleCenter:a,radius:c,samples_per_pixel:_,startX:l,startY:h,endX:o,endY:u}=i.data;let M;const Q=1/t,T=1/n,$=t/n;let j,y=new q(e,e);x.clear(),x.add(new Y(g(r,d([.5,.5,1],[.5,.5,1])),100,new I([.8,.8,0]))),x.add(new Y(g(a,d([.5,.5,1],[.5,.5,1])),c+.05,new N(1.5))),x.add(new J(d(a,[.4,.1,0]),g(a,[c-.3,c,c]),new I([.8,.8,.8]))),x.add(new K(g(a,[.3,-.1,0]),c,.2,new P([.8,.6,.2],1)));const D=new Uint8ClampedArray((o-l)*(u-h)*4);for(let z=l;z<o;z++){const k=(z+.5)*Q;for(let B=h;B<u;B++){const v=(B+.5)*T;M=[0,0,0];for(let S=0;S<_;S++)y.setDirection([$*(k-y.origin[0]+f(0,.001)),v-y.origin[1]+f(0,.001),-y.origin[2]]),j=L(y,s),M[0]+=j[0],M[1]+=j[1],M[2]+=j[2];const R=(z-l+(B-h)*(o-l))*4;D[R+0]=M[0]/_,D[R+1]=M[1]/_,D[R+2]=M[2]/_,D[R+3]=255}}self.postMessage({partImageData:D,startX:l,startY:h,endX:o,endY:u})}})();
